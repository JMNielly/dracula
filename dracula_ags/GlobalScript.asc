// main global script file
Dictionary* verbDictionary;
Dictionary* verbDescriptionDictionary;
Dictionary* notes;
float reachDistance = 30.0;
String lastCMD;
bool debugTools;
int nbFrameInSittingAnim;
int loopPerSecond;

// set default game options
function set_default_options()
{
  System.Volume = 100;
  sldAudio.Value = System.Volume;
  sldSpeed.Value = 40;
  SetGameSpeed(40);
}

// initialize gPanel
function initialize_control_panel()
{
  set_default_options();
}

// hide the icon bar and show a GUI
function open_gui(GUI* gui_to_open)
{
  if (gui_to_open != gInventory)
  {
    lblOverHotspot.Visible = false;
  }

  //gIconbar.Visible = false;
  mouse.UseModeGraphic(eModePointer);
  gui_to_open.Visible = true;
}

// hide the GUI and show the icon bar
function close_gui(GUI* gui_to_close)
{
  gui_to_close.Visible = false;
  mouse.UseDefaultGraphic();
  lblOverHotspot.Visible = true;
  //gIconbar.Visible = true;
}

// hide a GUI, based on a GUI control
function close_owning_gui(GUIControl* control)
{
  close_gui(control.OwningGUI);
}

// hide a GUI directly from an OnClick event
function close_gui_onclick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
}

// called when the game starts, before the first room is loaded
function game_start()
{
  // initialize gPanel controls
  initialize_control_panel();

  // set KeyboardMovement movement mode
  KeyboardMovement.Mode = eKeyboardMovementModeTapping;
  
  lastCMD = "";
  debugTools = true;
  nbFrameInSittingAnim = 2;
  loopPerSecond = 40;
  
  //Beard code
  cHarkersBeard.Transparency = 85;
  cHarkersBeard.ChangeRoom(cHarker.Room, cHarker.x, cHarker.y, eDirectionDown);
  cHarkersBeard.FollowCharacter(cHarker, FOLLOW_EXACTLY);
  
  notes = Dictionary.Create(eNonSorted);
  notes.Set("How to use", "When something notable is thought or said, you will see an asterisk (*) at the end of the sentence. Write the 'Note' command to add it to your notebook.");
  
  verbDictionary = Dictionary.Create(eNonSorted, eCaseInsensitive);
  verbDictionary.Set("look", "look");
  verbDictionary.Set("use", "use");
  //verbDictionary.Set("eat", "eat");
  //verbDictionary.Set("give", "give");
  verbDictionary.Set("examine", "look");
  verbDictionary.Set("open", "open");
  verbDictionary.Set("close", "close");
  verbDictionary.Set("go to", "approach");
  verbDictionary.Set("approach", "approach");
  verbDictionary.Set("note", "note");
  verbDictionary.Set("talk", "talk");
  verbDictionary.Set("speak", "talk");
  verbDictionary.Set("take", "take");
  verbDictionary.Set("get", "take");
  verbDictionary.Set("pick up", "take");
  verbDictionary.Set("read", "read");
  verbDictionary.Set("sit", "sit");
  verbDictionary.Set("stand", "stand");
  
  verbDescriptionDictionary = Dictionary.Create(eSorted, eCaseInsensitive);
  verbDescriptionDictionary.Set("look", "Look at something or someone in the room (or at one of your inventory items.[[EXAMPLE: Look carpet");
  verbDescriptionDictionary.Set("use", "Use an item from your inventory or an object in the room near you. Sometimes, you must specify on what or on whom you use the object.[[EXAMPLE 1: Use sink[[EXAMPLE 2: Use razor on myself");
  //verbDescriptionDictionary.Set("eat", "Consume something.[[EXAMPLE: Eat chicken");
  //verbDescriptionDictionary.Set("give", "Give an intem from your inventory to someone else. You must specify to whom you wish to give the item.[[EXAMPLE: Give ring to Mina");
  verbDescriptionDictionary.Set("open", "Open an object near you or an item from your inventory.[[EXAMPLE: Open front door");
  verbDescriptionDictionary.Set("close", "Close an object near you or an item from your inventory.[[EXAMPLE: Close bedroom door");
  verbDescriptionDictionary.Set("*approach", "Have Jonathan walk over to something or someone.[[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Approach dining table");
  verbDescriptionDictionary.Set("note", "Have Jonathan write down his notable information.[Only works when Jonathan has a notebook[[EXAMPLE: Note");
  verbDescriptionDictionary.Set("talk", "Talk to someone in the room.[Sometimes, you need to be near someone to talk to them.[[EXAMPLE: Talk to Count");
  verbDescriptionDictionary.Set("take", "Pick up an object and place it in your inventory.[[EXAMPLE: Take razor");
  verbDescriptionDictionary.Set("read", "Read an item from your inventory.[Not all items can be read.[[EXAMPLE: Read ledger");
  verbDescriptionDictionary.Set("sit", "Have Jonathan sit down in a nearby chair or appropriate surface.[Jonathan will not sit on any surface.[[EXAMPLE: Sit on bench");
  verbDescriptionDictionary.Set("*find", "Have Jonathan point out objects, people and inventory items that contain a certain word in its name.[Only works if 'Show hints' is chosen from the option panel.[[EXAMPLE: Find door");
  verbDescriptionDictionary.Set("stand", "Have Jonathan stand up.[[EXAMPLE: Stand up");
  
  int i;
  String myVerbs[] = verbDescriptionDictionary.GetKeysAsArray();
  
  for(i = 0; i < verbDescriptionDictionary.ItemCount; i++)
  {
    lbVerbs.AddItem(myVerbs[i]);
  }
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.TopItem]);
  
}

// called on every game cycle, except when the game is blocked
function repeatedly_execute()
{
  currentTime = currentTime + 2;
  if(currentTime > (loopPerSecond*86400)) {
    currentTime = currentTime - (loopPerSecond*86400);
  }
}

// called on every game cycle, even when the game is blocked
function repeatedly_execute_always()
{
  if(cHarkersBeard.Transparency < 100 && cHarker.GetProperty("sitting") == -1)
  {
    cHarkersBeard.FaceDirection(cHarker.Loop);
  }
}

// Called when a dialog script line "run-script" is processed
function dialog_request(int param)
{
}

function fillInventoryListBox ()
{
  int i;
  bool img = false;
  lbInventory.Clear();
  
  for(i = Game.InventoryItemCount ; i > 0 ; i--) 
  {
    if(player.HasInventory(inventory[i]))
    {
      lbInventory.AddItem(inventory[i].Name);
      if(img == false) {
        imgSelectedInv.NormalGraphic = inventory[i].Graphic;
        lblDescriptionSelectedItem.Text = inventory[i].GetTextProperty("TextDescription");
        img = true;
      }
    }
  }
}

function show_inventory_window()
{
  //mouse.Mode = eModeInteract;
  fillInventoryListBox();
  open_gui(gInventory);
}

function show_save_game_dialog()
{
  // get the list of save games
  lstSaveGamesList.FillSaveGameList();

  if (lstSaveGamesList.ItemCount > 0)
  {
    // if there is at least one, set the default text
    // to be the first game's name
    txtNewSaveName.Text = lstSaveGamesList.Items[0];
  }
  else
  {
    // no save games yet, so default to empty text
    txtNewSaveName.Text = "";
  }

  open_gui(gSaveGame);
}

function show_restore_game_dialog()
{
  lstRestoreGamesList.FillSaveGameList();
  open_gui(gRestoreGame);
}

//################## DEBUG DISPLAY FUNCTION ####################################

function debugDisplay(String message)
{
  if(debugTools){
    Display(message);
  }
}

//################## STRING CUSTOM FUNCTIONS ####################################

String keycodeToString(char typeCharacter)
{
  return String.Format("%c",  typeCharacter);
}

String etToString(elementType eT)
{
  switch(eT)
  {
    case roomObjects:
      return "roomObjects";
      break;
    case roomHotspots:
      return "roomHotspots";
      break;
    case allCharacters:
      return "allCharacters";
      break;
    case allInventoryItems:
      return "allInventoryItems";
      break;
    default:
      //debugDisplay(String.Format("Fxn etToString received element type #%d, out of bounds.", eT));
      break;
  }
}

elementType stringToET(String eT)
{
  switch(eT)
  {
    case "roomObjects":
      return roomObjects;
      break;
    case "roomHotspots":
      return roomHotspots;
      break;
    case "allCharacters":
      return allCharacters;
      break;
    case "allInventoryItems":
      return allInventoryItems;
      break;
    default:
      //debugDisplay(String.Format("Fxn stringToET received string %s, unknown.", eT));
      break;
  }
}

bool startsWithVowel(String word)
{
  bool doesStartWithAVowel = false;
  if(word.StartsWith("A", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("E", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("I", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("O", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("U", eCaseInsensitive)){
    doesStartWithAVowel = true;
  } else if(word.StartsWith("Y", eCaseInsensitive)){
    doesStartWithAVowel = true;
  }
  return doesStartWithAVowel;
}

String removeOneStringInstance(String fullText, String stringToRemoveOnce)
{
  int i;
  int finishAt = fullText.IndexOf(stringToRemoveOnce) + stringToRemoveOnce.Length;
  String finalReplacement = "";
  for(i = fullText.IndexOf(stringToRemoveOnce); i < finishAt; i++)
  {
    fullText = fullText.ReplaceCharAt(i, 95);
    finalReplacement = finalReplacement.Append("_");
  }
  fullText = fullText.Replace(finalReplacement, "", eCaseInsensitive);
  return fullText;
}

String[] split(String textToSplit, String separator)
{
  int i;
  String testString = textToSplit.Replace(separator, "", eCaseInsensitive);
  int nbStringItems = textToSplit.Length;
  nbStringItems = nbStringItems - testString.Length;
  
  String returnArray[] = new String[nbStringItems];
  returnArray[0] = String.Format("%d", nbStringItems);
  
  for(i = 1; i < nbStringItems; i++)
  {
    
    if(textToSplit.IndexOf(separator) != -1)
    {
      returnArray[i] = textToSplit.Substring(0, textToSplit.IndexOf(separator));
      textToSplit = removeOneStringInstance(textToSplit, returnArray[i].Append(separator));
    } else
    {
      returnArray[i] = textToSplit;
    }
  }
  
  return returnArray;
}

String cmdStartsWithUSEsynonym(String cmd)
{
  Set* USEsynonyms = Set.Create();
  USEsynonyms.Add("use");
  USEsynonyms.Add("put");
  USEsynonyms.Add("insert");
  
  String synonymList[] = USEsynonyms.GetItemsAsArray();
  int i = USEsynonyms.ItemCount -1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.StartsWith(synonymList[i], eCaseInsensitive))
    {
      foundMatch = synonymList[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

//################# INTERACTION AUTOMATION FUNCTIONS ###############################

//##### UTILITIES #####

float calculateDistanceFromCharacter(int targetX, int targetY,  Character* who)
{
  float deltaX = IntToFloat(targetX) - IntToFloat(who.x);
  float deltaY = IntToFloat(targetY) - IntToFloat(who.y);
  return Maths.Sqrt(Maths.RaiseToPower(deltaX, 2.0)+ Maths.RaiseToPower(deltaY, 2.0));  
}

bool isCharacterCloseEnough(int targetX, int targetY, float maxDistance,  Character* who)
{
  float dist = calculateDistanceFromCharacter(targetX, targetY, who);
  return dist < maxDistance;
}

bool isCharacterNearHotspot(Hotspot* HS, float maxDistance,  Character* who)
{
  return isCharacterCloseEnough(HS.WalkToX, HS.WalkToY, maxDistance,  who);  
}

bool isCharacterNearObject(Object* Obj, float maxDistance,  Character* who)
{
  return isCharacterCloseEnough(Obj.X, Obj.Y, maxDistance,  who);  
}

bool isCharacterNearCharacter(Character* target, float maxDistance,  Character* who)
{
  return isCharacterCloseEnough(target.x, target.y, maxDistance,  who);  
}

String whatIsThis(elementType eT, int index)
{
  switch(eT)
  {
    case roomObjects:
      return object[index].Name;
      break;
    case roomHotspots:
      return hotspot[index].Name;
      break;
    case allCharacters:
      return character[index].Name;
      break;
    case allInventoryItems:
      return inventory[index].Name;
      break;
    default: 
      //debugDisplay(String.Format("whatIsThis fxn received element type #%d, out of bounds.", eT));
      return "Unknown";
      break;
  }
}

String[] findClosestElement(String elementType_index[], float dist[], int arraysLength)
{
  String closestElementType_index = elementType_index[0];
  float closestDist = dist[0];
  String returnArray[] = new String[2];
  
  int i; 
  for(i = 1; i < arraysLength; i++)
  {
    if(dist[i] < closestDist) 
    {
      closestElementType_index = elementType_index[i];
      closestDist = dist[i];
    }
  }
  
  returnArray[0] = closestElementType_index.Truncate(closestElementType_index.IndexOf("_"));
  closestElementType_index = closestElementType_index.Replace(returnArray[0], "", eCaseInsensitive);
  closestElementType_index = closestElementType_index.Replace("_", "", eCaseInsensitive);
  returnArray[1] = closestElementType_index;
  
  return returnArray;
}

//##### TIME FUNCTION #####

//HERE 

//##### MAP FUCNTIONS #####

function enterMap()
{
  int i;  
  gMapIndications.Visible = true;
  for(i = 0 ; i < Room.ObjectCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = object[i].Name;
    gMapIndications.Controls[i].AsLabel.Visible = true;
    gMapIndications.Controls[i].AsLabel.X = object[i].X - gMapIndications.Controls[i].AsLabel.Width;
    gMapIndications.Controls[i].AsLabel.Y = object[i].Y;
    gMapIndications.Controls[i].AsLabel.TextAlignment = eAlignRight;
  }
}

function exitMap()
{
  int i;
  for(i = 0 ; i < gMapIndications.ControlCount ; i++)
  {
    gMapIndications.Controls[i].AsLabel.Text = "";
    gMapIndications.Controls[i].AsLabel.Visible = false;
  }
  gMapIndications.Visible = false;
}

//##### AUTOMATED ACTION FUNCTION #####

String getNoteDescription(String key)
{
  return notes.Get(key);
}

function takeNote()
{
  notes.Set(Notable_title, Notable_description);
  lbNoteTitles.AddItem(Notable_title);
  if (Game.DoOnceOnly(Notable_description)) {
    GiveScore(Notable_score);
  }
}

function makeNotable(String title, String description, int score)
{
  Notable_title = title;
  Notable_description = description;
  Notable_score = score;
}

function notableThought(String title, String description,  int score)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    player.Think(String.Format("%s*", description));
  } else {
    player.Think(description);
  }
}

function notableSay(Character* who, String title, String description,  int score)
{
  if(player.HasInventory(iNotebook))
  {
    makeNotable(title,  description,  score);
    who.Say(String.Format("%s*", description));
  } else {
    who.Say(description);
  }
}



function sit(elementType eT, int index, Character* who, int sittingView, bool alreadySat)
{
  String redir;
  
  switch(eT)
  {
    case roomObjects:
      if(who == player) {
        redir = object[index].GetTextProperty("sit_Direction");
        if(redir.StartsWith("redir", eCaseInsensitive))
        {
          redir = redir.Replace("redir", "", eCaseInsensitive);
          index = redir.AsInt;
        }
      }
      if(object[index].GetTextProperty("sit_Direction") == "Null")
      {
        who.Think("I cannot sit on this.");        
      } else if(!isCharacterNearObject(object[index], reachDistance, who))
      {
        who.Think(String.Format("I cannot reach the %s from here", object[index].Name.LowerCase()));
      } else
      {
        who.Move(object[index].X + object[index].GetProperty("sit_deltaX"), object[index].Y + object[index].GetProperty("sit_deltaY"), eBlock, eAnywhere);
        who.LockView(sittingView, eStopMoving);
        if(who == player) {
          cHarkersBeard.LockView(6, eKeepMoving);
        }
        who.SetProperty("sitting", index);
        
        if(!alreadySat)
        {
          switch(object[index].GetTextProperty("sit_Direction"))
          {
            case "down":
              who.Animate(0, 6, eOnce, eNoBlock, eForwards);
              break;
            case "left":
              who.Animate(1, 6, eOnce, eNoBlock, eForwards);
              break;
            case "right":
              who.Animate(2, 6, eOnce, eNoBlock, eForwards);
              break;
            case "down":
              who.Animate(3, 6, eOnce, eNoBlock, eForwards);
              break;
            default:
              //debugDisplay(String.Format("Tried to sit on object #%d, %s, 'sit_Direction' is wrong", index, object[index].Name));
              break;
          }
          if(who == player)
          {
            switch(object[index].GetTextProperty("sit_Direction"))
            {
              case "down":
                cHarkersBeard.Animate(0, 6, eOnce, eBlock, eForwards);
                break;
              case "left":
                cHarkersBeard.Animate(1, 6, eOnce, eBlock, eForwards);
                break;
              case "right":
                cHarkersBeard.Animate(2, 6, eOnce, eBlock, eForwards);
                break;
              case "down":
                cHarkersBeard.Animate(3, 6, eOnce, eBlock, eForwards);
                break;
              default:
                //debugDisplay(String.Format("Tried to sit on object #%d, %s, 'sit_Direction' is wrong", index, object[index].Name));
                break;
            }
          }
        } else {
          //debugDisplay(String.Format("%s is sitting[View = %d[Frame = %d", who.Name, sittingView, who.Frame));
          who.Frame = nbFrameInSittingAnim;
        }
        if(who == player)
        {
          mouse.Mode = eModePointer;
          KeyboardMovement.Mode = eKeyboardMovementModeNone;
        }
      }
      break;
    default:
      break;
  }
}

//##### PARSE COMMAND REACTIONS FUNCTIONS #####

int findRoomObjectIndexByName(String objectName)
{
  int i = Room.ObjectCount - 1;
  int foundMatch = -1;
  
  while(i >= 0 && foundMatch == -1)
  {
    if(object[i].Name.LowerCase() == objectName.LowerCase())
    {
      foundMatch = i;
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

String[] findElementIndexByName(String cmd)
{
  int i;
  int y;
  String testedStrings[];
  String allPossibleNames;
  String finalIndex;
  String finalElementType;
  bool foundMatch;
  float distanceFromPlayer;
  String tempArray[];
  float tempArrayF[];
  String returnArray[] = new String[2];
  
  int nbObjects = Room.ObjectCount;
  int nbHotpots = 50;
  int nbCharacters = Game.CharacterCount;
  int nbInventoryItems = Game.InventoryItemCount;//don't forget the index start at one
  Dictionary* correspondingRoomElements = Dictionary.Create(eSorted, eCaseInsensitive);
  
  //OBJECTS
  for(i = 0; i < (nbObjects); i++)
  {
    allPossibleNames = object[i].Name.Append(", ");
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      allPossibleNames = allPossibleNames.Append(object[i].GetTextProperty("alternateNames"));
      allPossibleNames = allPossibleNames.Append(", ");
    }
    //debugDisplay(allPossibleNames);
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      //debugDisplay(String.Format("Trying to find : %s[In : %s", testedStrings[y], cmd));
      if(object[i].Name != "" && testedStrings[y] != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        //debugDisplay(String.Format("Found something![Name: %s[Visible: %d[IwI: %d", object[i].Name, object[i].Visible, object[i].GetProperty("InteractableWhenInvisible")));
        if(object[i].Visible || object[i].GetProperty("InteractableWhenInvisible"))
        {
          //debugDisplay("FOUND IT !!");
          foundMatch = true;
          distanceFromPlayer = calculateDistanceFromCharacter(object[i].X, object[i].Y, player);
          correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomObjects)), String.Format("%d", FloatToInt(distanceFromPlayer)));
        } else {
          //debugDisplay("Skipped on visibility !!");
          y++;
        }
      } else {
        y++;
      }
    }
  }
  
  //HOTSPOTS
  for(i = 0; i < (nbHotpots); i++)
  {
    allPossibleNames = hotspot[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(hotspot[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      if(hotspot[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(hotspot[i].WalkToX, hotspot[i].WalkToY, player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(roomHotspots)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //CHARACTERS
  for(i = 0; i < (nbCharacters); i++)
  {
    allPossibleNames = character[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(character[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    while(y < testedStringsLength && !foundMatch)
    {
      //debugDisplay(String.Format("testString: %s", testedStrings[y]));
      if(character[i].Room == player.Room && character[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        distanceFromPlayer = calculateDistanceFromCharacter(character[i].x, character[i].y,  player);
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allCharacters)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //INVENTORY ITEMS
  for(i = 1; i <= (nbInventoryItems); i++)//inventory item index start at 1
  {
    allPossibleNames = inventory[i].Name.Append(", ");
    allPossibleNames = allPossibleNames.Append(inventory[i].GetTextProperty("alternateNames"));
    testedStrings = split(allPossibleNames, ", ");
    int testedStringsLength = testedStrings[0].AsInt;
    y = 1;
    foundMatch = false;
    
    while(y < testedStringsLength && !foundMatch)
    {
      if(player.HasInventory(inventory[i]) && inventory[i].Name != "" && cmd.IndexOf(testedStrings[y]) != -1)
      {
        foundMatch = true;
        if(cmd.IndexOf(" my ") != -1)
        {
          distanceFromPlayer = 0.0;
        } else {
          distanceFromPlayer = 400.0;
        }
        correspondingRoomElements.Set(String.Format("%d_%s", i, etToString(allInventoryItems)), String.Format("%d", FloatToInt(distanceFromPlayer)));
      } else {
        y++;
      }
    }
  }
  
  //debugDisplay(String.Format("correspondingRoomElements.ItemCount: %d", correspondingRoomElements.ItemCount));
  
  switch(correspondingRoomElements.ItemCount)
  {
    case 0:
      returnArray[0] = "-1";
      returnArray[1] = "Null";
      break;
    case 1:
      tempArray = correspondingRoomElements.GetKeysAsArray();
      finalIndex = tempArray[0].Truncate(tempArray[0].IndexOf("_"));
      finalElementType = tempArray[0].Replace(finalIndex, "", eCaseInsensitive);
      finalElementType = finalElementType.Replace("_", "", eCaseInsensitive);
      returnArray[0] = finalIndex;
      returnArray[1] = finalElementType;
      break;
    default:
      tempArray = correspondingRoomElements.GetValuesAsArray();
      tempArrayF = new float[correspondingRoomElements.ItemCount];
      for(i = 0; i < correspondingRoomElements.ItemCount; i++)
      {
        tempArrayF[i] = tempArray[i].AsFloat;
      }
      tempArray = correspondingRoomElements.GetKeysAsArray();
      returnArray = findClosestElement(tempArray, tempArrayF, correspondingRoomElements.ItemCount);
      break;
  }  
  
  return returnArray;
}

String findVerbInDictionary(String cmd)
{
  int i = verbDictionary.ItemCount -1;
  bool foundVerb = false;
  int stringPosition = -1;
  String verbs[] = verbDictionary.GetKeysAsArray();
   
  while(!foundVerb && i > -1){
    stringPosition = cmd.IndexOf(verbs[i]);
    if(stringPosition == -1) {
      i--;
    } else {
      foundVerb = true;
    }
  }
  
  if(i == -1) 
  {
    return "Null";
  } else {
    return verbDictionary.Get(verbs[i]);
  }
}

function fitInventoryItemsTogether(InventoryItem* keptItem, InventoryItem* fittedItem, String newKeptItemName, int newItemGraphic, bool ReplaceDesc_orAppend, String newItemDescription, int AddedScore)
{
  String oldDescription = keptItem.GetTextProperty("TextDescription");
  String oldName = keptItem.Name;
  
  keptItem.Name = newKeptItemName;
  if(ReplaceDesc_orAppend)
  {
    keptItem.SetTextProperty("TextDescription", newItemDescription);
  } else {
    keptItem.SetTextProperty("TextDescription", oldDescription.Append(String.Format(" %s", newItemDescription)));
  }
  keptItem.Graphic = newItemGraphic;
  player.LoseInventory(fittedItem);
  if(AddedScore > 0){
    if (Game.DoOnceOnly(String.Format("Fit %s in %s", fittedItem.Name, oldName))) {
      GiveScore(AddedScore);
    }
  }
}

function standUp(Character* who,  int walkingView)
{
  if(who.GetProperty("sitting") > -1)
  {
    who.Animate(player.Loop, 6, eOnce, eNoBlock,  eBackwards);
    if(who == player)
    {
      cHarkersBeard.Animate(player.Loop, 6, eOnce, eBlock, eBackwards);
    }
    who.LockView(walkingView, eKeepMoving);
    if(who == player)
    {
      cHarkersBeard.LockView(5, eKeepMoving);
    }
    who.PlaceOnWalkableArea();
    who.SetProperty("sitting", -1);
    if(who == player)
    {
      mouse.Mode = eModeWalkto;
      KeyboardMovement.Mode = eKeyboardMovementModeTapping;
    }
  } else {
    who.Think("I am not sitting");
  }
}

bool interact(String indexElementVerbHandled[])
{
  int index = indexElementVerbHandled[0].AsInt;
  elementType eT = stringToET(indexElementVerbHandled[1]);
  String verb = indexElementVerbHandled[2];
  String lookDescription;
  int alternateSpriteNumber;
  int walkableAreaNumber;
  bool handledInteraction = true;
  String readDescriptionFromItem;
  String currentPage;
  Set* readContent = Set.Create(eSorted);
  String readContentToDisplay[];
  int i;
  
  switch (verb)
  {
    case "look":
      switch (eT)
      {
        case roomObjects:
          if(object[index].Visible || object[index].GetProperty("InteractableWhenInvisible"))
          {
            lookDescription = object[index].GetTextProperty("TextDescription");
            player.FaceObject(object[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case roomHotspots:
          lookDescription = hotspot[index].GetTextProperty("TextDescription");
          player.FaceLocation(hotspot[index].WalkToX, hotspot[index].WalkToY, eBlock);
          player.Say(lookDescription);
          break;
        case allCharacters:
          if(character[index].Transparency < 100){
            lookDescription = character[index].GetTextProperty("TextDescription");
            player.FaceCharacter(character[index], eBlock);
            player.Say(lookDescription);
          } else {
            player.Say("I'm not sure what I'm looking at...");
          }
          break;
        case allInventoryItems:
          player.FaceDirection(eDirectionDown, eBlock);
          lookDescription = inventory[index].GetTextProperty("TextDescription");
          player.Say(lookDescription);
          break;
        default:
          player.Say("I'm not sure what I'm looking at...");
          break;
      }
      break;
    case "open":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Open_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) {
              if(!object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already opened");
              } else {
                object[index].Visible = true;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RestoreWalkableArea(walkableAreaNumber);
            }
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Open_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot open this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already opened");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot open this");
          break;
      }
      break;
    case "close":
      switch(eT)
      {
        case roomObjects:
          alternateSpriteNumber = object[index].GetProperty("Close_SpriteNumber");
          walkableAreaNumber = object[index].GetProperty("WalkableArea_opened");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(isCharacterNearObject(object[index], reachDistance,  player))
          {
            if(alternateSpriteNumber == -2) 
            {
              if(!object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else if(object[index].Graphic == alternateSpriteNumber)
            {
              if(object[index].Visible)
              {
                player.Think("It is already closed");
              } else {
                object[index].Visible = false;
              }
            } else {
              object[index].Graphic = alternateSpriteNumber;
            }
            if(walkableAreaNumber != -1)
            {
              RemoveWalkableArea(walkableAreaNumber);
            } 
          } else {
            player.Think("I can't reach from here");
          }
          break;
        case allInventoryItems:
          alternateSpriteNumber = inventory[index].GetProperty("Close_SpriteNumber");
          if(alternateSpriteNumber == -1)
          {
            player.Think("I cannot close this");
          } else if(inventory[index].Graphic == alternateSpriteNumber) 
          {
            player.Think("It is already closed");
          } else {
            inventory[index].Graphic = alternateSpriteNumber;
          }
          break;
        default:
          player.Think("I cannot close this");
          break;
      }
      break;
    case "approach":
      if(!showHints){
        player.Think("I can walk there on my own");
      } else {
        switch(eT)
        {
          case roomObjects:
            player.Walk(object[index].X, object[index].Y, eNoBlock, eWalkableAreas);
            break;
          case roomHotspots:
            player.Walk(hotspot[index].WalkToX, hotspot[index].WalkToY, eNoBlock, eWalkableAreas);
            break;
          case allCharacters:
            player.Walk(character[index].x, character[index].y, eNoBlock, eWalkableAreas);
            break;
          default:
            player.Think("I am not not where to go");
            break;
        }
      }
      break;
    case "sit":
      sit(eT, index, player, 2,  false);
      break;
    case "take":
      if(eT == roomObjects)
      {
        if(object[index].GetProperty("takable") != -1)
        {
          if(isCharacterNearObject(object[index], reachDistance, player))
          {
            player.Think("This can be useful");
            player.AddInventory(inventory[object[index].GetProperty("takable")]);
            object[index].Visible = false;
            GiveScore(1);
          } else {
            player.Think("I need to go a little closer");
          }
        } else {
          player.Think("I would rather leave this where it is");
        }
      }
      break;
    case "talk":
      switch (eT)
      {
        case allCharacters:
          if(character[index].Room != player.Room)
          {
            player.Think("I am not sure whom to speak to");
          } else
          {
            if (character[index].GetProperty("dialogIndex") == -1)
            {
              player.FaceCharacter(character[index], eBlock);
              player.Think("I do not know what I should say.");
            } else 
            {
              if (character[index].GetProperty("dialogMaxDistance") > -1 && !isCharacterNearCharacter(character[index], IntToFloat(character[index].GetProperty("dialogMaxDistance")), player))
              {
                player.FaceCharacter(character[index], eBlock);
                player.Think(String.Format("%s will not hear me from this distance", character[index].Name));
              } else 
              {
                if (character[index].GetProperty("dialogWhileSitting") != -1 && (player.GetProperty("sitting") != character[index].GetProperty("dialogWhileSitting")))
                {
                player.FaceCharacter(character[index], eBlock);
                  player.Think(String.Format("Politeness dictates that I should sit in the %s before speaking to %s", object[character[index].GetProperty("dialogWhileSitting")].Name.LowerCase(), character[index].Name));
                } else
                {
                  dialog[character[index].GetProperty("dialogIndex")].Start();
                }
              }
            }
          }
          break;
        default:
          player.Think("I am not sure whom to speak to");
          break;
      }
      break;
    case "read":
      if(eT == allInventoryItems && inventory[index].GetTextProperty("ReadDisplay") != "Null")
      {
        readDescriptionFromItem = inventory[index].GetTextProperty("ReadDisplay");
        while(readDescriptionFromItem.IndexOf("¶") != -1)
        {
          currentPage = readDescriptionFromItem.Truncate(readDescriptionFromItem.IndexOf("¶"));
          currentPage = currentPage.Replace("¶", "", eCaseInsensitive);
          readContent.Add(currentPage);
          readDescriptionFromItem = removeOneStringInstance(readDescriptionFromItem, currentPage.Append("¶"));
        }
        readContent.Add(readDescriptionFromItem);
        readContentToDisplay = readContent.GetItemsAsArray();
        for(i = 0 ; i < readContent.ItemCount ; i++)
        {
          Display(readContentToDisplay[i]);
        }
      } else {
        player.Think("I cannot read this");
      }
      break;
    default:
      handledInteraction = false;
      break;
  }
  return handledInteraction;
}

String whichArticle(String listOfElementsMentionned, String newElementName){
  int counter = 1;
  while(listOfElementsMentionned.IndexOf(newElementName) != -1)
  {
    counter++;
    listOfElementsMentionned = removeOneStringInstance(listOfElementsMentionned, newElementName);
  }
  switch(counter)
  {
    case 0:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 1:
      if(startsWithVowel(newElementName))
      {
        return "An";
      } else
      {
        return "A";
      }
      break;
    case 2:
      return "A second";
      break;
    case 3:
      return "A third";
      break;
    case 4:
      return "A fourth";
      break;
    case 5:
      return "A fifth";
      break;
    default:
      return "Another";
      break;
  }
}

function findElementContaining(String keyword)
{
  int i;
  bool intro = false;
  bool invIntro = false;
  String nameAndAKA;
  String article = "";
  String allElementsMentionned = "";
  
  //OBJECTS IN THE ROOM
  for(i = 0; i < Room.ObjectCount; i++) {
    nameAndAKA = object[i].Name;
    if(object[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(object[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can see...");
        intro = true;
      }
      player.FaceObject(object[i], eBlock);
      article = whichArticle(allElementsMentionned, object[i].Name);
      player.Say(String.Format("%s %s over there.", article,  object[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", object[i].Name));
    }
  }
  //HOTSPOTS IN THE ROOM
  for(i = 0; i < 50; i++) {
    nameAndAKA = hotspot[i].Name;
    if(hotspot[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(hotspot[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1) {
      if(!intro)
      {
        player.Say("Looking around, I can see...");
        intro = true;
      }
      player.FaceLocation(hotspot[i].WalkToX, hotspot[i].WalkToY, eBlock);
      article = whichArticle(allElementsMentionned, hotspot[i].Name);
      player.Say(String.Format("%s %s over there.", article,  hotspot[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", hotspot[i].Name));
    }
  }
  //CHARACTERS IN THE ROOM
  for(i = 0; i < Game.CharacterCount; i++) {
    nameAndAKA = character[i].Name;
    if(character[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(character[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.Room == character[i].Room) {
      if(!intro)
      {
        player.Say("Looking around, I can see...");
        intro = true;
      }
      player.FaceCharacter(character[i]);
      player.Say(String.Format("%s over there.", character[i].Name));
    }
  }
  //OWNED INVENTORY ITEMS
  for(i = 1; i <= Game.InventoryItemCount; i++) {
    nameAndAKA = inventory[i].Name;
    if(inventory[i].GetTextProperty("alternateNames") != "")
    {
      nameAndAKA = nameAndAKA.Append(", ");
      nameAndAKA = nameAndAKA.Append(inventory[i].GetTextProperty("alternateNames"));
    }
    if(nameAndAKA.IndexOf(keyword) != -1 && player.HasInventory(inventory[i])) {
      if(!invIntro)
      {
        if(intro)
        {
          player.Say("Also...");
        }
        player.Say("In my inventory, I can find...");
        invIntro = true;
        intro = true;
      }
      player.FaceDirection(eDirectionDown);
      article = whichArticle(allElementsMentionned, inventory[i].Name);
      player.Say(String.Format("%s %s.", article, inventory[i].Name));
      allElementsMentionned = allElementsMentionned.Append(String.Format("%s ", inventory[i].Name));
    }
  }
}

String isInteractionOnElement(String cmd)
{
  Set* OnSynonyms = Set.Create(eSorted);
  OnSynonyms.Add("in");
  OnSynonyms.Add("into");
  OnSynonyms.Add("onto");
  OnSynonyms.Add("on");
  OnSynonyms.Add("over");
  OnSynonyms.Add("with");
  OnSynonyms.Add("under");
  OnSynonyms.Add("to");
  
  String OnSynonymsArray[] = OnSynonyms.GetItemsAsArray();
  int i = OnSynonyms.ItemCount - 1;
  String foundMatch = "Null";
  
  while(i >= 0 && foundMatch == "Null")
  {
    if(cmd.IndexOf(OnSynonymsArray[i]) != -1)
    {
      foundMatch = OnSynonymsArray[i];
    } else {
      i--;
    }
  }
  
  return foundMatch;
}

function unhandled_event(int what, int type) {
  
  switch(what)
  {
    case 2: // room object
      switch(type)
      {
        case 1: // use/interact with object
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on object
          break;
        default:
          break;
      }
      break;
    case 1: // hotspot
      switch(type)
      {
        case 2: // use/interact with hotspot
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on hotspot
          break;
        default:
          break;
      }
      break;
    case 3: // character
      switch(type)
      {
        case 1: // use/interact character
          player.Think("I am not sure what to use them for");
          break;
        case 3: // use inventory item on character
          break;
        default:
          break;
      }
      break;
    case 5: // inventory item
      switch(type)
      {
        case 1: // use/interact with inventory item
          player.Think("I am not sure what to use this for");
          break;
        case 3: // use inventory item on inventory item
          break;
        default:
          break;
      }
      break;
    case 4: // nothing
      switch(type)
      {
        case 2: // use/interact with nothing
          player.Think("I am not sure what to use");
          break;
        case 3: // use inventory item on nothing
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}

function useInteraction(String cmd) // USE!
{
  String OnSynonym = isInteractionOnElement(cmd);
  String useSynonym = cmdStartsWithUSEsynonym(cmd);
  
  String cmdUsed;
  String cmdOn;
  
  String indexElementUsed[] = new String[2];
  elementType eTUsed;
  int indexUsed;
  bool canUse = true;
  
  String indexElementOn[] = new String[2];
  elementType eTOn;
  int indexOn;
  
  elementType eTTemp;
  int indexTemp;
  
  if(OnSynonym == "Null") // there is only one verb (use) and a target
  {
      cmd = removeOneStringInstance(cmd, useSynonym.Append(" ")); // HEREE
      indexElementUsed = findElementIndexByName(cmd);
      
      if(indexElementUsed[1] == "Null")
      {
        player.Think("I am not sure what to use");
      } else {
        eTUsed = stringToET(indexElementUsed[1]);
        indexUsed = indexElementUsed[0].AsInt;
        switch(eTUsed)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexUsed], reachDistance, player))
            {
              object[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", object[indexUsed].Name.LowerCase()));
            }
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexUsed], reachDistance, player))
            {
              hotspot[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use it", hotspot[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexUsed]))
            {
              inventory[indexUsed].RunInteraction(eModeInteract);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            player.Think("I am not sure what you want me to use");
            break;
        }
      } 
  } else // The player wants to use something on/with something
  {
    cmd = removeOneStringInstance(cmd, useSynonym.Append(" "));
    cmdUsed = cmd.Truncate(cmd.IndexOf(OnSynonym));
    cmd = removeOneStringInstance(cmd, cmdUsed);
    cmdOn = removeOneStringInstance(cmd, OnSynonym);
    
    indexElementUsed = findElementIndexByName(cmdUsed);
    indexElementOn = findElementIndexByName(cmdOn);
    
    if(indexElementOn[1] == "Null" || indexElementUsed[1] == "Null")
    {
      player.Think("I am not sure what you want me to do");
    } else {
      eTUsed = stringToET(indexElementUsed[1]);
      indexUsed = indexElementUsed[0].AsInt;
      eTOn = stringToET(indexElementOn[1]);
      indexOn = indexElementOn[0].AsInt;
      
      if(eTOn == allInventoryItems && eTUsed != allInventoryItems) // if the 2nd is an item but not the first,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      if(eTUsed == allCharacters && eTOn != allCharacters) // if the 1st is a character but not the second,  invert them
      {
        indexTemp = indexOn;
        eTTemp = eTOn;
        indexOn = indexUsed;
        eTOn = eTUsed;
        indexUsed = indexTemp;
        eTUsed = eTTemp;
      }
      
      if(eTUsed == allInventoryItems)
      {
        if(!player.HasInventory(inventory[indexUsed]))
        {
          canUse = false;
        }
      } else if (eTUsed == allCharacters)
      {
        if(character[indexUsed].Room != player.Room)
        {
          canUse = false;
        }
      }
          
          
      if(canUse)
      {
        activeElementToUse_ElementType = etToString(eTUsed);
        activeElementToUse_Index = indexUsed;
        
        //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
        
        switch(eTOn)
        {
          case roomObjects:
            if(isCharacterNearObject(object[indexOn], reachDistance, player))
            {
              object[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", object[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }              
            break;
          case roomHotspots:
            if(isCharacterNearHotspot(hotspot[indexOn], reachDistance, player))
            {
              hotspot[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to the %s to use my %s on it", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allCharacters:
            if(character[indexOn].Room == player.Room && isCharacterNearCharacter(character[indexOn], reachDistance, player))
            {
              character[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think(String.Format("I need to get closer to %s to use my %s on them", hotspot[indexOn].Name.LowerCase(), inventory[indexUsed].Name.LowerCase()));
            }
            break;
          case allInventoryItems:
            if(player.HasInventory(inventory[indexOn]))
            {
              inventory[indexOn].RunInteraction(eModeUseinv);
            } else {
              player.Think("I am not sure what you want me to use");
            }
            break;
          default:
            break;
        }
      } else {
        player.Think("I am not sure what you want me to use");
      }
    }
  }
}



String[] roomSpecificParse(String cmd)
{
  String elementName;
  String indexElement[] = new String[2];
  String indexElementVerbHandled[] = new String[4];
  indexElementVerbHandled[0] = "Null";
  indexElementVerbHandled[1] = "Null";
  indexElementVerbHandled[2] = "Skip";
  indexElementVerbHandled[3] = "true";
  
  if(cmd.IndexOf("find ") != -1) {                                                                    // FIND KEYWORD
    cmd = cmd.Replace("find ", "", eCaseInsensitive);
    cmd = cmd.Replace("all ", "", eCaseInsensitive);
    cmd = cmd.Replace("any ", "", eCaseInsensitive);
    findElementContaining(cmd);
  } else if(cmd.LowerCase() == "stand" || cmd.IndexOf("stand ") != -1) {                              // STAND KEYWORD
    standUp(player, 1);
  } else if(cmdStartsWithUSEsynonym(cmd) != "Null") {                                                 // USE KEYWORDS
    useInteraction(cmd);
  } else if(cmd.StartsWith("shave", eCaseInsensitive)) {
    if(player.HasInventory(iRazor))
    {
      useInteraction("use razor on myself");
    } else {
      player.Think("I need to find my razor to shave");
    }
  } else if (cmd.StartsWith("Note ", eCaseInsensitive) || cmd.LowerCase() == "note" || cmd.LowerCase() == "take note") {  // NOTE KEYWORD
    takeNote();
  }
  else
  {
    indexElement = findElementIndexByName(cmd);
    
    indexElementVerbHandled[0] = indexElement[0];
    indexElementVerbHandled[1] = indexElement[1];
    //debugDisplay(String.Format("%s[%s", indexElement[0], indexElement[1]));
    if(indexElement[1] != "Null") {
      indexElementVerbHandled[2] = findVerbInDictionary(cmd);
    } else {
      indexElementVerbHandled[2] = "Null";
    }
  }
  
  return indexElementVerbHandled;
}

// called when a key is pressed
function on_key_press(eKeyCode keycode, int mod)
{
  // check for Escape first, so it can be used on GUIs that pause the game
  if (keycode == eKeyEscape)
  {
    if (gRestart.Visible)
    {
      // Escape will cancel a restart
      close_gui(gRestart);
    }
    else if (gPanel.Visible)
    {
      // Escape will turn the panel off
      close_gui(gPanel);
    }
    else if (gSaveGame.Visible)
    {
      // Escape will close the save game dialog
      close_gui(gSaveGame);
    }
    else if (gRestoreGame.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gRestoreGame);
    }
    else if (gInventory.Visible)
    {
      // Escape will close the restore game dialog
      close_gui(gInventory);
    }
    else if (gExitGame.Visible)
    {
      // Escape will cancel exiting the game
      close_gui(gExitGame);
    }
    else if (gParser.Visible) {
      // Escape will cancel the text parser
      close_gui(gParser);
    }
    else
    {
      // Escape will turn the panel on
      open_gui(gPanel);
    }
  } 
  else if (IsGamePaused() || !IsInterfaceEnabled())
  {
    // game paused, so don't react to any keypresses
    keycode = 0;
  }
  else if (keycode == eKeyQ && (mod & eKeyModCtrl))
  {
    // Ctrl-Q will quit the game
    open_gui(gExitGame);
  }
  else if (keycode == eKeyF5)
  {
    // F5 will prompt to save a game
    show_save_game_dialog();
  }
  else if (keycode == eKeyF7)
  {
    // F7 will prompt to save a game
    show_restore_game_dialog();
  }
  else if (keycode == eKeyF9)
  {
    // F9 will prompt to restart the game
    open_gui(gRestart);
  }
  else if (keycode == eKeyF12)
  {
    // F12 will save a screenshot to the save game folder
    SaveScreenShot("screenshot.pcx");
  }
  else if (keycode >= 65 && keycode <= 90)
  {
    open_gui(gParser);
    tbParser.Text = keycodeToString(keycode);
  }
  else if (keycode == eKeyF3)
  {
    open_gui(gParser);
    tbParser.Text = lastCMD;
  }
  else if (keycode == eKeyTab)
  {
    // Tab opens the inventory
    show_inventory_window();
  }
  else if (mod & eKeyModCtrl)
  {
    if (keycode == eKeyS)
    {
      // Ctrl-S will give the player all defined inventory items
      Debug(0, 0);
    }
    else if (keycode == eKeyV)
    {
      // Ctrl-V will show game engine version and build date
      Debug(1, 0);
    }
    else if (keycode == eKeyA)
    {
      // Ctrl-A will show walkable areas
      Debug(2, 3);
    }
    else if (keycode == eKeyX)
    {
      // Ctrl-X will let the player teleport to any room
      Debug(3, 0);
    }
  }
}

// called when a mouse button is clicked
function on_mouse_click(MouseButton button)
{
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  if (IsGamePaused())
  {
    // game is paused, so do nothing (i.e. don't process mouse clicks)
  }
  else if (button == eMouseLeft)
  {
    // left-click, so try using the current mouse cursor mode at this position
    //Room.ProcessClick(mouse.x, mouse.y, mouse.Mode );
    if(player.GetProperty("sitting") == -1)
    {
      player.Walk(mouse.x, mouse.y, eNoBlock, eWalkableAreas);
    } else {
      int destX = mouse.x;
      int destY = mouse.y;
      standUp(player, 1);
      player.Walk(destX, destY, eNoBlock, eWalkableAreas);
    }
  }
  /*else if (button == eMouseRight || button == eMouseWheelSouth){
    // right-click or mouse wheel down will cycle the mouse cursor mode forwards
    mouse.SelectNextMode();
  }*/
  /*else if (button == eMouseMiddle)
  {
    // middle-click makes the character walk to clicked area, regardless of cursor mode
    Room.ProcessClick(mouse.x, mouse.y, eModeWalkto);
  }*/
  /*else if (button == eMouseWheelNorth)
  {
    // mouse wheel up will cycle the cursor mode backwards
    mouse.SelectPreviousMode();
  }*/
}

function btnIconInv_Click(GUIControl *control, MouseButton button)
{
  show_inventory_window();
}

function btnIconCurInv_Click(GUIControl *control, MouseButton button)
{
  if (player.ActiveInventory != null)
  {
    mouse.Mode = eModeUseinv;
  }
}

function btnIconSave_Click(GUIControl *control, MouseButton button)
{
  show_save_game_dialog();
}

function btnIconLoad_Click(GUIControl *control, MouseButton button)
{
  show_restore_game_dialog();
}

function btnIconExit_Click(GUIControl *control, MouseButton button)
{
  open_gui(gExitGame);
}

function btnIconAbout_Click(GUIControl *control, MouseButton button)
{
  open_gui(gPanel);
}

//START OF CONTROL PANEL FUNCTIONS
function btnSave_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  Wait(1);
  //btnIconSave_Click(btnIconSave, eMouseLeft);
}

function btnAbout_OnClick(GUIControl *control, MouseButton button)
{
  Display("%s[AGS %s", Game.Name, System.Version);
}

function btnQuit_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gExitGame);
}

function btnLoad_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  Wait(1);
  //btnIconLoad_Click(btnIconLoad, eMouseLeft);
}

function sldAudio_OnChange(GUIControl *control)
{
  System.Volume = sldAudio.Value;
}

function btnDefault_OnClick(GUIControl *control, MouseButton button)
{
  set_default_options();
}
//END OF CONTROL PANEL FUNCTIONS

function sldSpeed_OnChange(GUIControl *control)
{
  SetGameSpeed(sldSpeed.Value);
}

function btnRestart_OnClick(GUIControl *control, MouseButton button)
{
  close_owning_gui(control);
  open_gui(gRestart);
}

function btnRestartYes_OnClick(GUIControl *control, MouseButton button)
{
  RestartGame();
}

int find_save_slot(String name)
{
  bool slots[] = new bool[999];
  int i = 0;

  while (i < lstSaveGamesList.ItemCount)
  {
    if (lstSaveGamesList.Items[i] == name)
    {
      // found existing save with matching name
      return lstSaveGamesList.SaveGameSlots[i];
    }

    // remember which slots are already taken
    slots[lstSaveGamesList.SaveGameSlots[i]] = true;
    i ++;
  }

  // find first free save slot, starting with slot 1
  i = 1;

  while (i < 999)
  {
    if (!slots[i])
    {
      return i;
    }

    i ++;
  }

  // no free slots found
  return -1;
}

function btnSaveGame_OnClick(GUIControl *control, MouseButton button)
{
  int gameSlotToSaveInto = find_save_slot(txtNewSaveName.Text);

  if (gameSlotToSaveInto < 0)
  {
    Display("No more free save slots!");
  }
  else
  {
    SaveGameSlot(gameSlotToSaveInto, txtNewSaveName.Text);
    close_owning_gui(control);
  }
}

function btnRestoreGame_OnClick(GUIControl *control, MouseButton button)
{
  if (lstRestoreGamesList.SelectedIndex >= 0)
  {
    RestoreGameSlot(lstRestoreGamesList.SaveGameSlots[lstRestoreGamesList.SelectedIndex]);
  }

  close_owning_gui(control);
}

function lstSaveGamesList_OnSelectionCh(GUIControl *control)
{
  txtNewSaveName.Text = lstSaveGamesList.Items[lstSaveGamesList.SelectedIndex];
}

function txtNewSaveName_OnActivate(GUIControl *control)
{
  // pressing Return in the text box simulates clicking the save button
  btnSaveGame_OnClick(control, eMouseLeft);
}

function btnDeleteSave_OnClick(GUIControl *control, MouseButton button)
{
  if (lstSaveGamesList.SelectedIndex >= 0)
  {
    DeleteSaveSlot(lstSaveGamesList.SaveGameSlots[lstSaveGamesList.SelectedIndex]);
    lstSaveGamesList.FillSaveGameList();
  }
}

function btnConfirmedQuit_OnClick(GUIControl *control, MouseButton button)
{
  QuitGame(0);
}

function lbInventory_OnSelectionChanged(GUIControl *control)
{
  int i = Game.InventoryItemCount;
  String itemName = lbInventory.Items[lbInventory.SelectedIndex];
  bool foundMatch = false;
  
  while(i > 0 && !foundMatch) 
  {
    if(inventory[i].Name == itemName)
    {
      imgSelectedInv.NormalGraphic = inventory[i].Graphic;
      lblDescriptionSelectedItem.Text = inventory[i].GetTextProperty("TextDescription");
      foundMatch = true;
    } else {
      i--;
    }
  }
  
  
}

function btnToggleHints_OnClick(GUIControl *control, MouseButton button)
{
  if(showHints)
  {
    lblOverHotspot.Visible = false;
    lblOverHotspot.Text = "";
    btnToggleHints.Text = "Hide hints";
    showHints = false;
  } else {
    lblOverHotspot.Text = "@OVERHOTSPOT@";
    lblOverHotspot.Visible = true;
    btnToggleHints.Text = "Show hints";
    showHints = true;
  }
}

function tbParser_OnActivate(GUIControl *control)
{
  //PRESS ENTER
  if(gParser.Visible) {
    String cmd = tbParser.Text;
    lastCMD = cmd;
    CallRoomScript (1);
  }
}

function lbVerbs_OnSelectionChanged(GUIControl *control)
{
  lblHelpVerbDesc.Text = verbDescriptionDictionary.Get(lbVerbs.Items[lbVerbs.SelectedIndex]);
}

function btnHelpPanel_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gHelp);
  close_gui(gPanel);
}

function btnHelpResume_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gHelp);
  open_gui(gPanel);
}

function cHarker_UseInv()
{
  int shavingGlassObjectIndex = findRoomObjectIndexByName("shaving glass");
  
  //debugDisplay(String.Format("%s[%d", activeElementToUse_ElementType, activeElementToUse_Index));
  
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 3)//razor
  {
    if(cHarkersBeard.Transparency == 100)
    {
      player.Think("I do not need to shave");
    } else if(shavingGlassObjectIndex == -1)
    {
      player.Think("I cannot shave here");
    } else if(!object[shavingGlassObjectIndex].Visible && player.HasInventory(iMirror))
    {
      player.Think("I need to install my shaving glass first");
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think("There seems to be an appropriate surface over there");
    } else if(object[shavingGlassObjectIndex].Visible && !isCharacterNearObject(object[shavingGlassObjectIndex], reachDistance, player))
    {
      player.FaceObject(object[shavingGlassObjectIndex]);
      player.Think(String.Format("I need to get closer to the %s", object[shavingGlassObjectIndex].Name));
    } else {
      player.FaceObject(object[shavingGlassObjectIndex]);
      cHarkersBeard.Transparency = 100;
      player.Think("Ah, prefectly smooth");
      if (Game.DoOnceOnly("perfect shave")) {
        GiveScore(1);
      }
    }
  }
}



function iLegalPapers_UseInv()
{
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 7)//folder
  {
    fitInventoryItemsTogether(iLegalPapers, iFolder, "Legal dossier", 124, true, "A folder of contracts I need to bring to Mr. Hawkins.", 1);
    player.Think("Good idea. I will put the contracts in the folder for a neater look");
  }
}
function iFolder_UseInv()
{
  if(activeElementToUse_ElementType == "allInventoryItems" && activeElementToUse_Index == 6)//Legal papers
  {
    fitInventoryItemsTogether(iLegalPapers, iFolder, "Legal dossier", 124, true, "A folder of contracts I need to bring to Mr. Hawkins.", 1);
    player.Think("Good idea. I will put the contracts in the folder for a neater look");
  }
}

function updateNotebook()
{
  lbNoteTitles.Clear();
  String notesToAdd[] = notes.GetKeysAsArray();
  int i;
  
  for(i = 0 ; i < notes.ItemCount ; i++)
  {
    lbNoteTitles.AddItem(notesToAdd[i]);
  }
  
  lbNoteTitles.SelectedIndex = 0;
  lblNoteDescription.Text = notes.Get(lbNoteTitles.Items[lbNoteTitles.SelectedIndex]);
  btnDeleteNote.Enabled = (notes.ItemCount > 1); // must have at least 2 entries to remove one.  
}

function btnNoteBook_OnClick(GUIControl *control, MouseButton button)
{
  updateNotebook();
  open_gui(gNotebook);
}

function btnResume_notebook_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gNotebook);
}

function btnConfirmCancel_OnClick(GUIControl *control, MouseButton button)
{
  close_gui(gConfirm);
}

function btnConfirmYes_OnClick(GUIControl *control, MouseButton button)
{
  if(gNotebook.Visible) // delete note
  {
    String noteTitle = lbNoteTitles.Items[lbNoteTitles.SelectedIndex];
    notes.Remove(noteTitle);
    lbNoteTitles.RemoveItem(lbNoteTitles.SelectedIndex);
    lbNoteTitles.SelectedIndex = 0;
  }
  close_gui(gConfirm);
}

function btnDelete_OnClick(GUIControl *control, MouseButton button)
{
  open_gui(gConfirm);
}
